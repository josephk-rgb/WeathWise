import { useAuth0 } from '@auth0/auth0-react';
import { useEffect, useState, useRef } from 'react';
import { apiService } from '../services/api';

export const useAuth = () => {
  const {
    isAuthenticated,
    isLoading,
    user,
    loginWithRedirect,
    logout,
    getAccessTokenSilently,
  } = useAuth0();

  const [tokenReady, setTokenReady] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const initializingRef = useRef(false); // Use ref to prevent React Strict Mode issues

  // Automatically get and set token when authenticated
  useEffect(() => {
    
    // FORCE token initialization for debugging - remove the tokenInitialized check temporarily
    if (isAuthenticated && user && !isLoading && !isInitializing && !initializingRef.current) {
      const initializeToken = async () => {
        try {
          initializingRef.current = true; // Set ref immediately
          setIsInitializing(true);
          setTokenInitialized(true);
          
          const token = await getAccessTokenSilently({
            authorizationParams: {
              audience: import.meta.env.VITE_AUTH0_AUDIENCE,
              scope: "openid profile email"
            }
          });
          
          // Decode and log the token payload
          try {
            const tokenParts = token.split('.');
            const payload = JSON.parse(atob(tokenParts[1]));
          } catch (decodeError) {
            console.error('ðŸ”§ [FRONTEND] Failed to decode token:', decodeError);
          }
          
          apiService.setToken(token);
          setTokenReady(true);
        } catch (error) {
          console.error('Error getting Auth0 token:', error);
          setTokenReady(false);
          setTokenInitialized(false);
          initializingRef.current = false;
          
          // Try to get token silently with different parameters
          try {
            const fallbackToken = await getAccessTokenSilently();
            console.log('Got fallback Auth0 token:', fallbackToken.substring(0, 30) + '...');
            apiService.setToken(fallbackToken);
            setTokenReady(true);
            setTokenInitialized(true);
          } catch (fallbackError) {
            console.error('Fallback token retrieval also failed:', fallbackError);
          }
        } finally {
          setIsInitializing(false);
        }
      };
      
      initializeToken();
    } else if (!isAuthenticated && !isLoading) {
      console.log('User not authenticated, clearing token');
      setTokenReady(false);
      setTokenInitialized(false);
      setIsInitializing(false);
      initializingRef.current = false;
      apiService.clearToken();
    }
  }, [isAuthenticated, user, isLoading, getAccessTokenSilently]); // Removed tokenInitialized from dependencies

  const login = () => {
    
    loginWithRedirect({
      authorizationParams: {
        audience: import.meta.env.VITE_AUTH0_AUDIENCE,
        scope: "openid profile email"
      }
    });
  };

  const handleLogout = () => {
    logout({ logoutParams: { returnTo: window.location.origin } });
    apiService.clearToken();
    setTokenReady(false);
    setTokenInitialized(false);
    setIsInitializing(false);
    initializingRef.current = false;
  };

  const getToken = async () => {
    try {
      const token = await getAccessTokenSilently({
        authorizationParams: {
          audience: import.meta.env.VITE_AUTH0_AUDIENCE,
          scope: "openid profile email"
        }
      });
      
      // Decode and log the fresh token payload too
      try {
        const tokenParts = token.split('.');
        const payload = JSON.parse(atob(tokenParts[1]));
      } catch (decodeError) {
        console.error('ðŸ”§ [FRONTEND] Failed to decode fresh token:', decodeError);
      }
      
      apiService.setToken(token);
      setTokenReady(true);
      return token;
    } catch (error) {
      console.error('Error getting token:', error);
      setTokenReady(false);
      return null;
    }
  };

  return {
    isAuthenticated,
    isLoading,
    user,
    tokenReady,
    login,
    logout: handleLogout,
    getToken,
  };
};
